#!/usr/bin/python3
"""
Parses and displays log files generated by logging systems.
"""

import os
import argparse
import time
import glob
from watchdog.observers import Observer
from watchdog.events import LoggingEventHandler

COLORS = dict()


def color_type(entry_type):
    """Returns color escape code based on type."""
    ret = str()
    if entry_type == "FATAL":
        ret = "\033[1;31m"
    elif entry_type == "ERROR":
        ret = "\033[31m"
    elif entry_type == "WARNING":
        ret = "\033[33m"
    elif entry_type == "TRACE":
        ret = "\033[34m"
    elif entry_type == "DEBUG":
        ret = "\033[94m"
    elif entry_type == "SUCCESS":
        ret = "\033[32m"
    elif entry_type == "INFO":
        ret = "\033[97m"
    elif entry_type == "DATA":
        ret = "\033[0m"
    elif entry_type == "VERSION":
        ret = "\033[1;33m"
    else:
        ret = "\033[0m"
    return ret


def color_file(file):
    """Returns color escape code based on file/src name."""
    global COLORS
    if file in COLORS:
        return COLORS[file]
    COLORS[file] = "\033[38;5;{}m".format(len(COLORS) + 1)
    return COLORS[file]


def fmt(entry, spacing, color, order):
    while spacing[2] < len(entry[2]):
        entry[2] = '::'.join(entry[2].split('::')[1:])
    if spacing[3] < len(entry[3]):
        entry[3] = "{}...".format(entry[3][:spacing[3] - 3])
    if color == 'none':
        return [
            "{:{}}".format(entry[i], spacing[i] + 3)
            for i in range(len(entry))
        ]
    if color == 'default':
        if order == 0 or order == 3 or order == 4:
            return [color_type(entry[0])] + [
                "{:{}}".format(entry[i], spacing[i] + 3)
                for i in range(len(entry))
            ]
        elif order == 1:
            return [color_file(entry[1])] + [
                "{:{}}".format(entry[i], spacing[i] + 3)
                for i in range(len(entry))
            ]
        elif order == 2:
            return [color_file(entry[2])] + [
                "{:{}}".format(entry[i], spacing[i] + 3)
                for i in range(len(entry))
            ]
    return "NULL"


def load_data(file_path):
    data = list()
    with open(file_path, 'r') as file:
        for line in file:
            var = line.split()
            data.append([var[0][1:-1], var[1][1:-1], var[2][1:-1], ' '.join(var[3:])])
            # data.append([
            #     var[0][1:], var[1][2:].split('@')[0], var[1][2:].split('@')[1],
            #     var[2][2:], var[3][1:-1]
            # ])
    return data


def shorten(spacing, data, columns):
    if sum(spacing) + (3 * len(spacing)) > columns:
        length = 0
        for entry in data:
            length = max(len(entry[2].split('::')[-1]), length)
        spacing[2] = length
    if sum(spacing) + (3 * len(spacing)) > columns:
        spacing[4] = columns - (3 * len(spacing)) - (
            spacing[0] + spacing[1] + spacing[2] + spacing[3])


def print_entry(entry, spacing, color, order):
    blocks = fmt(entry, spacing, color, order)
    print(''.join(blocks))


def print_data(data, order=0, color='default', columns=80):
    spacing = [0, 0, 0, 0, 0]
    data = sorted(data, key=lambda x: x[order])
    for entry in data:
        for i in range(len(entry)):
            if len(entry[i]) > spacing[i]:
                spacing[i] = len(entry[i])
    shorten(spacing, data, columns)
    for entry in data:
        print_entry(entry, spacing, color, order)

def run(args):
    rows, columns = os.popen('stty size', 'r').read().split()
    columns = int(columns)
    data = load_data(args.file)
    print_data(data, ["time", "file", "src", "type", "msg"].index(args.sort),
               'default', columns)
    print("\033[0m", end='')
    return len(data)


def monitor(args):
    stamp = os.path.getmtime(args.file)
    lines = 0
    update=True
    try:
        while True:
            if update is True:
                if lines != 0:
                    for i in range(lines):
                        print('\033[2K', end='\033[F')
                    print('\033[2K', end='')
                lines = run(args)
                update = False
            time.sleep(1)
            new_stamp = os.path.getmtime(args.file)
            if new_stamp != stamp:
                stamp = new_stamp
                update = True
    except KeyboardInterrupt:
        pass

def main():
    parser = argparse.ArgumentParser('Log')
    parser.add_argument("file", help="Log file", nargs='?' ,default="*.log")
    parser.add_argument(
        "--sort",
        "-s",
        help="Sorting",
        choices=['time', 'file', 'src', 'type', 'msg'],
        default='time')
    parser.add_argument('-m', help='Live moitor log output', action='store_true')
    args = parser.parse_args()
    files = glob.glob(args.file)
    if not os.path.isfile(args.file) and not files:
        print("\"{}\" is not a valid log file".format(args.file))
        exit(1)
    elif files:
        args.file = files[0]
    if args.m == False:
        run(args)
    else:
        monitor(args)


if __name__ == "__main__":
    main()
